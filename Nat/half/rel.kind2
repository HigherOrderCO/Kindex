// Halves a number. Returns the half, `h`, a proof that either `h*2=n` or `h*2+1=n`.
Nat.half.rel (n: Nat) : [m: Nat] (Either (Equal Nat n (Nat.double m)) (Equal Nat n (Nat.succ (Nat.double m))))
Nat.half.rel Nat.zero = $ Nat.zero (Either.left Equal.refl)
Nat.half.rel (Nat.succ n) =
  let ind = Nat.half.rel n
  Nat.half.rel.pred n ind

Nat.half.rel.pred
  (n: Nat)
  (s: ([m: Nat] -> (Either (Equal Nat n (Nat.double m)) (Equal Nat n (Nat.succ (Nat.double m))))))
: ([m: Nat] -> (Either (Equal Nat (Nat.succ n) (Nat.double m)) (Equal Nat (Nat.succ n) (Nat.succ (Nat.double m)))))
Nat.half.rel.pred n (Sigma.new a b fst snd) =
  // FIXME: we need a subst primitive, to avoid this ugly code
  //let snd = snd :: subst 0 b in b fst // replaces `b` by its first value on the reduction context
  let b.e = Equal.refl :: Equal (a -> Type) b (m => (Either (Equal Nat n (Nat.double m)) (Equal Nat n (Nat.succ (Nat.double m)))))
  let snd = Equal.rewrite b.e ((b: a -> Type) => b fst) snd
  Nat.half.rel.test n fst snd

Nat.half.rel.test
  (n: Nat)
  (m: Nat)
  (e: Either (Equal Nat n (Nat.double m)) (Equal Nat n (Nat.succ (Nat.double m))))
: [m: Nat] -> Either (Equal Nat (Nat.succ n) (Nat.double m)) (Equal Nat (Nat.succ n) (Nat.succ (Nat.double m)))
Nat.half.rel.test n m (Either.left  e.a e.b e.value) = $ m            (Either.right (Equal.apply (x => Nat.succ x) e.value))
Nat.half.rel.test n m (Either.right e.a e.b e.value) = $ (Nat.succ m) (Either.left  (Equal.apply (x => Nat.succ x) e.value))
