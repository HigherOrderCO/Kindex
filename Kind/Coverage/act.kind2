Impossible <a> (reason: String) : a

Kind.Coverage.cover_constructor (context: Kind.Context) (depth: U60) (clauses: List Kind.Rule) (ty: Kind.Term) (body: Kind.Term -> Kind.Term) (constructor: U60): Pair U60 Kind.SplitTree
Kind.Coverage.cover_constructor ctx depth clauses ty body constr =
  let creator   = Constructor.CreatorOf constr
  let type_cons = Constructor.TypeOf constr
  let matches   = Kind.Coverage.match_type ctx depth type_cons ty
  if matches {
    let new_ty      = Kind.Coverage.specialize_type creator body
    let specialized = Kind.Coverage.specialize clauses constr
    Pair.new constr (Kind.Coverage.cover ctx depth specialized new_ty)
  } else {
    Pair.new constr (Kind.SplitTree.impossible)
  }

Kind.Coverage.is_uncovered.list (split: List (Pair U60 Kind.SplitTree)): Bool
Kind.Coverage.is_uncovered.list (List.cons t pair xs) = Bool.or (Kind.Coverage.is_uncovered (Pair.snd pair)) (Kind.Coverage.is_uncovered.list xs)
Kind.Coverage.is_uncovered.list List.nil = Bool.false

Kind.Coverage.is_uncovered (split: Kind.SplitTree): Bool
Kind.Coverage.is_uncovered Kind.SplitTree.uncovered    = Bool.true
Kind.Coverage.is_uncovered (Kind.SplitTree.split list) = Kind.Coverage.is_uncovered.list list
Kind.Coverage.is_uncovered other = Bool.false

Kind.Coverage.map_constructor (context: Kind.Context) (depth: U60) (clauses: List Kind.Rule) (ty: Kind.Term) (body: Kind.Term -> Kind.Term) (constructors: List U60) : List (Pair U60 Kind.SplitTree)
Kind.Coverage.map_constructor ctx dep clauses typ body (List.nil t)       = List.nil
Kind.Coverage.map_constructor ctx dep clauses typ body (List.cons t constructor xs) =
  let res = Kind.Coverage.cover_constructor ctx dep clauses typ body constructor
  if Kind.Coverage.is_uncovered (Pair.snd res) {
    List.cons res List.nil
  } else {
    let tail = Kind.Coverage.map_constructor ctx dep clauses typ body xs
    List.cons res tail
  }

Kind.Coverage.act (context: Kind.Context) (depth: U60) (clauses: List Kind.Rule) (funTy: Kind.Term) : Kind.SplitTree
Kind.Coverage.act ctx dep clauses (Kind.Term.all orig_ name typ body) =
  if Kind.Coverage.can_intro clauses {
    let ctx  = Kind.Context.extend ctx name typ []
    let res  = Kind.Term.eval (body (Kind.Term.var orig_ name dep))
    let tree = Kind.Coverage.cover ctx (+ dep 1) (Kind.Coverage.intro clauses) res
    let locate_tree =
      (if U60.equal name 0 {
        (tree => tree) :: _ -> _
      } else {
        (tree =>  Kind.SplitTree.intro tree) :: _ -> _
      }) :: Kind.SplitTree -> Kind.SplitTree
    locate_tree tree
  } else {
    let data_type = Kind.Coverage.get_inductive typ
    match Maybe data_type {
      some =>
        let constructors = Family.ConstructorsOf data_type.value
        let res = Kind.Coverage.map_constructor ctx dep clauses typ body constructors
        Kind.SplitTree.split res
      none => Impossible "an induction in something that is not inductive is.. strange"
    }
  }

Kind.Coverage.act ctx dep clauses funTy = Kind.SplitTree.uncovered
