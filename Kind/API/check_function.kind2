Kind.API.is_on_error.go (k: Kind.Result Unit) : Bool
Kind.API.is_on_error.go (Kind.Result.checked c d r s e (List.nil t_) r_) = Bool.false
Kind.API.is_on_error.go other = Bool.true

Kind.API.is_on_error (ls: List (Kind.Result Unit)) : Bool
Kind.API.is_on_error (List.nil t)         = Bool.false
Kind.API.is_on_error (List.cons t res xs) = if Kind.API.is_on_error.go res { Bool.true } else { Kind.API.is_on_error xs }

Kind.API.check_function (fnid: U60): List (Kind.Result Unit)
Kind.API.check_function fnid =
  let rules = Kind.Axiom.rule_of fnid
  let type  = Kind.Axiom.type_of fnid
  let type_check = Kind.Checker.run (Kind.Checker.unify (Kind.Checker.check type (Kind.Term.typ 0))) Bool.true
  let rule_check = Kind.API.check_function.rules rules (Kind.Term.eval type)
  let result = List.cons type_check rule_check
  if Bool.or (Kind.API.is_on_error result) (Bool.not (Kind.Axiom.should_check fnid)) {
    result
  } else {
    List.cons (Kind.Checker.run (Kind.Coverage.check_coverage fnid rules type) Bool.true) result
  }

Kind.API.check_function.rules (rules: List Kind.Rule) (type: Kind.Term): List (Kind.Result Unit)
Kind.API.check_function.rules (List.nil t)             type = List.nil
Kind.API.check_function.rules (List.cons t rule rules) type =
  let head = Kind.Checker.run (Kind.Checker.unify (Kind.Checker.rule rule type)) Bool.false
  let tail = Kind.API.check_function.rules rules type
  (List.cons head tail)

