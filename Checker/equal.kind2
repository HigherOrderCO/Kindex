Null <a> : a

HashOf (u: U60): U60

Checker.equal (left: Term) (right: Term): Checker Bool

Checker.equal (Term.typ orig) (Term.typ orig1) =
  Checker.pure Bool.true

Checker.equal (Term.all a.orig a.name a.type a.body) (Term.all b.orig b.name b.type b.body) =
  do Checker {
    ask dep  = Checker.get_depth
    ask type = Checker.equal a.type b.type
    ask body = Checker.extended (Checker.equal (a.body (Term.var a.orig a.name dep)) (b.body (Term.var b.orig b.name dep))) Null Null Null
    return (Bool.and type body)
  }

Checker.equal (Term.lam a.orig a.name a.body) (Term.lam b.orig b.name b.body) =
  do Checker {
    ask dep  = Checker.get_depth
    ask body = Checker.extended (Checker.equal (a.body (Term.var a.orig a.name dep)) (b.body (Term.var b.orig b.name dep))) Null Null Null
    return body
  }

Checker.equal (Term.app a.orig a.func a.argm) (Term.app b.orig b.func b.argm) =
  do Checker {
    ask func = Checker.equal a.func b.func
    ask argm = Checker.equal a.argm b.argm
    return (Bool.and func argm)
  }

Checker.equal (Term.let a.orig a.name a.expr a.body) (Term.let b.orig b.name b.expr b.body) =
  do Checker {
    ask dep  = Checker.get_depth
    ask expr = Checker.equal a.expr b.expr
    ask body = Checker.extended (Checker.equal (a.body (Term.var a.orig a.name dep)) (b.body (Term.var b.orig b.name dep))) Null Null Null
    return (Bool.and expr body)
  }

Checker.equal (Term.ann a.orig a.expr a.type) (Term.ann b.orig b.expr b.type) =
  do Checker {
    ask func = Checker.equal a.expr b.expr
    ask argm = Checker.equal a.type b.type
    return (Bool.and func argm)
  }

Checker.equal (Term.ann a.orig a.expr a.type) (Term.ann b.orig b.expr b.type) =
  do Checker {
    ask func = Checker.equal a.expr b.expr
    ask argm = Checker.equal a.type b.type
    return (Bool.and func argm)
  }

Checker.equal (Term.u60 a.orig) (Term.u60 b.orig) =
  Checker.pure Bool.true

Checker.equal (Term.num a.orig a.num) (Term.num b.orig b.num) =
  Checker.pure (U60.equal a.num b.num)

Checker.equal (Term.op2 a.orig a.op a.val0 a.val1) (Term.op2 b.orig b.op b.val0 b.val1) =
  // TODO: Compare operators
  do Checker {
    ask val0 = Checker.equal a.val0 b.val0
    ask val1 = Checker.equal a.val1 b.val1
    return Bool.and val0 val1
  }

Checker.equal (Term.hol a.orig a.numb) b =
  Checker.equal.hol a.orig a.numb b

Checker.equal b (Term.hol a.orig a.numb) =
  Checker.equal.hol a.orig a.numb b

Checker.equal (Term.var a.orig a.name a.index) b =
  do Checker {
    ask rhs = Checker.get_right_hand_side
    (Checker.equal.var rhs a.orig a.name a.index b)
  }

Checker.equal b (Term.var a.orig a.name a.index) =
  do Checker {
    ask rhs = Checker.get_right_hand_side
    (Checker.equal.var rhs a.orig a.name a.index b)
  }

Checker.equal (Term.ct0 a.ctid a.orig) (Term.ct0 b.ctid b.orig) =
  do Checker {
    let ctid = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    return ctid
  }

Checker.equal (Term.ct1 a.ctid a.orig a.x0) (Term.ct1 b.ctid b.orig b.x0) =
  do Checker {
    let ctid = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    ask x0   = Checker.equal a.x0 b.x0
    return Bool.and ctid x0
  }

Checker.equal (Term.ct2 a.ctid a.orig a.x0 a.x1) (Term.ct2 b.ctid b.orig b.x0 b.x1) =
  do Checker {
    let ctid = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    ask x0   = Checker.equal a.x0 b.x0
    ask x1   = Checker.equal a.x1 b.x1
    return Bool.and ctid (Bool.and x0 x1)
  }

Checker.equal (Term.ct3 a.ctid a.orig a.x0 a.x1 a.x2) (Term.ct3 b.ctid b.orig b.x0 b.x1 b.x2) =
  do Checker {
    let ctid = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    ask x0   = Checker.equal a.x0 b.x0
    ask x1   = Checker.equal a.x1 b.x1
    ask x2   = Checker.equal a.x2 b.x2
    return Bool.and ctid (Bool.and x0 (Bool.and x1 x2))
  }

Checker.equal (Term.ct4 a.ctid a.orig a.x0 a.x1 a.x2 a.x3) (Term.ct4 b.ctid b.orig b.x0 b.x1 b.x2 b.x3) =
  do Checker {
    let ctid = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    ask x0   = Checker.equal a.x0 b.x0
    ask x1   = Checker.equal a.x1 b.x1
    ask x2   = Checker.equal a.x2 b.x2
    ask x3   = Checker.equal a.x3 b.x3
    return Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 x3)))
  }

Checker.equal (Term.ct5 a.ctid a.orig a.x0 a.x1 a.x2 a.x3 a.x4) (Term.ct5 b.ctid b.orig b.x0 b.x1 b.x2 b.x3 b.x4) =
  do Checker {
    let ctid = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    ask x0   = Checker.equal a.x0 b.x0
    ask x1   = Checker.equal a.x1 b.x1
    ask x2   = Checker.equal a.x2 b.x2
    ask x3   = Checker.equal a.x3 b.x3
    ask x4   = Checker.equal a.x4 b.x4
    return Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 x4))))
  }

Checker.equal (Term.ct6 a.ctid a.orig a.x0 a.x1 a.x2 a.x3 a.x4 a.x5) (Term.ct6 b.ctid b.orig b.x0 b.x1 b.x2 b.x3 b.x4 b.x5) =
  do Checker {
    let ctid = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    ask x0   = Checker.equal a.x0 b.x0
    ask x1   = Checker.equal a.x1 b.x1
    ask x2   = Checker.equal a.x2 b.x2
    ask x3   = Checker.equal a.x3 b.x3
    ask x4   = Checker.equal a.x4 b.x4
    ask x5   = Checker.equal a.x5 b.x5
    return Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 (Bool.and x4 x5)))))
  }

Checker.equal (Term.args7 a.x0 a.x1 a.x2 a.x3 a.x4 a.x5 a.x6) (Term.args7 b.x0 b.x1 b.x2 b.x3 b.x4 b.x5 b.x6) =
  do Checker {
    ask x0   = Checker.equal a.x0 b.x0
    ask x1   = Checker.equal a.x1 b.x1
    ask x2   = Checker.equal a.x2 b.x2
    ask x3   = Checker.equal a.x3 b.x3
    ask x4   = Checker.equal a.x4 b.x4
    ask x5   = Checker.equal a.x5 b.x5
    ask x6   = Checker.equal a.x6 b.x6
    return Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 (Bool.and x4 (Bool.and x5 x6)))))
  }

Checker.equal (Term.args8 a.x0 a.x1 a.x2 a.x3 a.x4 a.x5 a.x6 a.x7) (Term.args8 b.x0 b.x1 b.x2 b.x3 b.x4 b.x5 b.x6 b.x7) =
  do Checker {
    ask x0   = Checker.equal a.x0 b.x0
    ask x1   = Checker.equal a.x1 b.x1
    ask x2   = Checker.equal a.x2 b.x2
    ask x3   = Checker.equal a.x3 b.x3
    ask x4   = Checker.equal a.x4 b.x4
    ask x5   = Checker.equal a.x5 b.x5
    ask x6   = Checker.equal a.x6 b.x6
    ask x7   = Checker.equal a.x7 b.x7
    return Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 (Bool.and x4 (Bool.and x5 (Bool.and x6 x7))))))
  }

Checker.equal (Term.ct7 a.ctid a.orig a.args) (Term.ct7 b.ctid b.orig b.args) =
  do Checker {
    let ctid  = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    ask xargs = Checker.equal a.args b.args
    return Bool.and ctid xargs
  }

Checker.equal (Term.ct8 a.ctid a.orig a.args) (Term.ct8 b.ctid b.orig b.args) =
  do Checker {
    let ctid  = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    ask xargs = Checker.equal a.args b.args
    return Bool.and ctid xargs
  }

Checker.equal (Term.fn0 a.ctid a.orig) (Term.fn0 b.ctid b.orig) =
  do Checker {
    let ctid = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    return ctid
  }

Checker.equal (Term.fn1 a.ctid a.orig a.x0) (Term.fn1 b.ctid b.orig b.x0) =
  do Checker {
    let ctid = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    ask x0   = Checker.equal a.x0 b.x0
    return Bool.and ctid x0
  }

Checker.equal (Term.fn2 a.ctid a.orig a.x0 a.x1) (Term.fn2 b.ctid b.orig b.x0 b.x1) =
  do Checker {
    let ctid = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    ask x0   = Checker.equal a.x0 b.x0
    ask x1   = Checker.equal a.x1 b.x1
    return Bool.and ctid (Bool.and x0 x1)
  }

Checker.equal (Term.fn3 a.ctid a.orig a.x0 a.x1 a.x2) (Term.fn3 b.ctid b.orig b.x0 b.x1 b.x2) =
  do Checker {
    let ctid = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    ask x0   = Checker.equal a.x0 b.x0
    ask x1   = Checker.equal a.x1 b.x1
    ask x2   = Checker.equal a.x2 b.x2
    return Bool.and ctid (Bool.and x0 (Bool.and x1 x2))
  }

Checker.equal (Term.fn4 a.ctid a.orig a.x0 a.x1 a.x2 a.x3) (Term.fn4 b.ctid b.orig b.x0 b.x1 b.x2 b.x3) =
  do Checker {
    let ctid = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    ask x0   = Checker.equal a.x0 b.x0
    ask x1   = Checker.equal a.x1 b.x1
    ask x2   = Checker.equal a.x2 b.x2
    ask x3   = Checker.equal a.x3 b.x3
    return Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 x3)))
  }

Checker.equal (Term.fn5 a.ctid a.orig a.x0 a.x1 a.x2 a.x3 a.x4) (Term.fn5 b.ctid b.orig b.x0 b.x1 b.x2 b.x3 b.x4) =
  do Checker {
    let ctid = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    ask x0   = Checker.equal a.x0 b.x0
    ask x1   = Checker.equal a.x1 b.x1
    ask x2   = Checker.equal a.x2 b.x2
    ask x3   = Checker.equal a.x3 b.x3
    ask x4   = Checker.equal a.x4 b.x4
    return Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 x4))))
  }

Checker.equal (Term.fn6 a.ctid a.orig a.x0 a.x1 a.x2 a.x3 a.x4 a.x5) (Term.fn6 b.ctid b.orig b.x0 b.x1 b.x2 b.x3 b.x4 b.x5) =
  do Checker {
    let ctid = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    ask x0   = Checker.equal a.x0 b.x0
    ask x1   = Checker.equal a.x1 b.x1
    ask x2   = Checker.equal a.x2 b.x2
    ask x3   = Checker.equal a.x3 b.x3
    ask x4   = Checker.equal a.x4 b.x4
    ask x5   = Checker.equal a.x5 b.x5
    return Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 (Bool.and x4 x5)))))
  }

Checker.equal (Term.fn7 a.ctid a.orig a.args) (Term.fn7 b.ctid b.orig b.args) =
  do Checker {
    let ctid  = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    ask xargs = Checker.equal a.args b.args
    return Bool.and ctid xargs
  }

Checker.equal (Term.fn8 a.ctid a.orig a.args) (Term.fn8 b.ctid b.orig b.args) =
  do Checker {
    let ctid  = U60.equal (HashOf a.ctid) (HashOf b.ctid)
    ask xargs = Checker.equal a.args b.args
    return Bool.and ctid xargs
  }

Checker.equal a b =
  do Checker {
    ask sub = Checker.get_subst
    if Bool.or (Term.fillable a sub) (Term.fillable b sub) {
      Checker.equal (Term.fill a sub) (Term.fill b sub)
    } else {
      Checker.pure Bool.false
    }
  }

Checker.equal.var (rhs: Bool) (orig: U60) (name: U60) (index: U60) (b: Term): Checker Bool

Checker.equal.var Bool.false orig name index b =
  do Checker {
    ask Checker.add_value index b
    return Bool.true
  }

Checker.equal.var Bool.true a.orig a.name a.index (Term.var b.orig b.name b.index) =
  if U60.equal a.index b.index {
    Checker.pure Bool.true
  } else {
    do Checker {
      ask a.val = Checker.find a.index [] (n => t => v => v)
      ask b.val = Checker.find b.index [] (n => t => v => v)
      ask a.chk = Checker.equal.var.try_values a.val (Term.var b.orig b.name b.index)
      ask b.chk = Checker.equal.var.try_values b.val (Term.var a.orig a.name a.index)
      return Bool.or a.chk b.chk
    }
  }

Checker.equal.var Bool.true a.orig a.name a.index b =
  do Checker {
    ask sub = Checker.get_subst
    if Term.fillable b sub {
      Checker.equal (Term.var a.orig a.name a.index) (Term.fill b sub)
    } else {
      do Checker {
        ask a.val = Checker.find a.index [] (n => t => v => v)
        // TODO: Check why i cannot simply return the value instead of having
        // to create a variable to it.
        ask res   = Checker.equal.var.try_values a.val b
        return res
      }
    }
  }

Checker.equal.var.try_values (ls: List Term) (term: Term): Checker Bool
Checker.equal.var.try_values (List.nil t)       term = Checker.pure Bool.false
Checker.equal.var.try_values (List.cons t x xs) term =
  do Checker {
    ask head = Checker.equal x term
    if head {
      Checker.pure Bool.true
    } else {
      Checker.equal.var.try_values xs term
    }
  }

Checker.equal.hol (orig: U60) (numb: U60) (b: Term): Checker Bool
Checker.equal.hol a.orig a.numb b =
  do Checker {
    ask got = Checker.look a.numb
    ask res = Checker.equal.hol.val got a.orig a.numb b
    return res
  }

Checker.equal.hol.val (val: Maybe Term) (orig: U60) (numb: U60) (b: Term): Checker Bool
Checker.equal.hol.val (Maybe.none t) orig numb b =
  do Checker {
    ask Checker.fill numb b
    return Bool.true
  }

Checker.equal.hol.val (Maybe.some t val) orig numb b =
  Checker.equal val b
