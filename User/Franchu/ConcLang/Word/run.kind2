List.push <type: Type> (list: (List type)) (value: type): (List type)
List.push type (List.nil u) value = (List.pure type value)
List.push type (List.cons u head tail) value = (List.cons u head (List.push tail value))

List.pop <type: Type> (list: (List type)): (Pair (List type) (Maybe type))
List.pop type (List.nil u) = (Pair.new List.nil (Maybe.none type))
List.pop type (List.cons u fst (List.nil u2)) = (Pair.new List.nil (Maybe.some fst))
List.pop type (List.cons u fst (List.cons u2 head tail)) =
	let res = (List.pop (List.cons head tail))
	(Pair.new (List.cons fst (Pair.fst res)) (Pair.snd res))

User.Franchu.ConcLang.Word.run (word: User.Franchu.ConcLang.Word) (state: User.Franchu.ConcLang.ProgramState): User.Franchu.ConcLang.ProgramState

User.Franchu.ConcLang.Word.run User.Franchu.ConcLang.Word.enstack (User.Franchu.ConcLang.ProgramState.new
	stack
	(List.cons User.Franchu.ConcLang.Value q_head q_tail)
) = 
	(User.Franchu.ConcLang.ProgramState.new (List.cons q_head stack) q_tail)

User.Franchu.ConcLang.Word.run User.Franchu.ConcLang.Word.enqueue (User.Franchu.ConcLang.ProgramState.new
	(List.cons User.Franchu.ConcLang.Value s_head s_tail)
	queue
) = 
	(User.Franchu.ConcLang.ProgramState.new s_tail (List.cons s_head queue))
	
User.Franchu.ConcLang.Word.run User.Franchu.ConcLang.Word.swap (User.Franchu.ConcLang.ProgramState.new
	(List.cons User.Franchu.ConcLang.Value fst (List.cons User.Franchu.ConcLang.Value snd s_tail))
	queue
) = 
	(User.Franchu.ConcLang.ProgramState.new
		(List.cons User.Franchu.ConcLang.Value snd (List.cons User.Franchu.ConcLang.Value fst s_tail))
		queue
	)
	
	
User.Franchu.ConcLang.Word.run User.Franchu.ConcLang.Word.discard (User.Franchu.ConcLang.ProgramState.new
	(List.cons User.Franchu.ConcLang.Value s_head s_tail)
	queue
) = 
	(User.Franchu.ConcLang.ProgramState.new s_tail queue)
	
User.Franchu.ConcLang.Word.run User.Franchu.ConcLang.Word.dup (User.Franchu.ConcLang.ProgramState.new
	(List.cons User.Franchu.ConcLang.Value s_head s_tail)
	queue
) = 
	(User.Franchu.ConcLang.ProgramState.new (List.cons User.Franchu.ConcLang.Value s_head (List.cons User.Franchu.ConcLang.Value s_head s_tail)) queue)
	
User.Franchu.ConcLang.Word.run (User.Franchu.ConcLang.Word.group words) (User.Franchu.ConcLang.ProgramState.new
	stack
	queue
) = 
	(User.Franchu.ConcLang.ProgramState.new stack (List.concat words queue))

User.Franchu.ConcLang.Word.run User.Franchu.ConcLang.Word.close (User.Franchu.ConcLang.ProgramState.new
	(List.cons User.Franchu.ConcLang.Value fst (List.cons User.Franchu.ConcLang.Value (User.Franchu.ConcLang.Value.word (User.Franchu.ConcLang.Word.group g)) s_tail))
	queue
) = 
	(User.Franchu.ConcLang.ProgramState.new
		(List.cons User.Franchu.ConcLang.Value (User.Franchu.ConcLang.Value.word (User.Franchu.ConcLang.Word.group (List.cons fst g))) s_tail)
		queue
	)

User.Franchu.ConcLang.Word.run (User.Franchu.ConcLang.Word.extern fn) program_state = 
	(fn program_state)
	
User.Franchu.ConcLang.Word.run User.Franchu.ConcLang.Word.cache (User.Franchu.ConcLang.ProgramState.new
	(List.cons User.Franchu.ConcLang.Value s_head s_tail)
	queue
) = 
	(User.Franchu.ConcLang.ProgramState.new s_tail (List.push queue s_head))

User.Franchu.ConcLang.Word.run User.Franchu.ConcLang.Word.decache (User.Franchu.ConcLang.ProgramState.new
	stack
	queue
) = 
	let result = (List.pop queue)
	(Maybe.match 
		User.Franchu.ConcLang.Value
		(Pair.snd result)
		@p(User.Franchu.ConcLang.ProgramState)
		(User.Franchu.ConcLang.ProgramState.new stack (Pair.fst result))
		@x(User.Franchu.ConcLang.ProgramState.new (List.cons x stack) (Pair.fst result))
	)
