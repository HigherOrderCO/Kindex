// This is a draft of Fib's Pos type

// Positions.range (center: Pos) (deltas: List Pos) : List ([pos: Pos] (Apps.Fib.InRange pos))
// Apps.Fib.Pos.to_key (pos: U120) (inrange: Apps.Fib.InRange pos) : Key ....

// A position is represented as a U120 value. Each coordinate uses 9 bits. For
// a U120 value to be a valid position, each coordinate must be less than 320.
// 00000000 00000000 00000000 00000000 00000000
// 00000000 00000000 00000000 00000000 00000000
// 00000000 00000000 000000yy yyyyyyyx xxxxxxxx
Apps.Fib.Pos : Type {
  [value: U120] (Apps.Fib.Pos.Value.IsValid value)
}

// A U120 coordinate is valid if it is less than 320
Apps.Fib.Pos.Coord.IsValid (coord: U120) : Type
//Apps.Fib.Pos.Coord.IsValid (U120.new 0 0) = Unit
Apps.Fib.Pos.Coord.IsValid coord = U120.IsLessThan coord (U120.new 0 320)

// A U120 value is a valid position if each coordinate is less than 320.
Apps.Fib.Pos.Value.IsValid (value: U120) : Type
//Apps.Fib.Pos.Value.IsValid (U120.new 0 0) = Unit
Apps.Fib.Pos.Value.IsValid value =
  let x.chk = Apps.Fib.Pos.Coord.IsValid (Apps.Fib.Pos.Value.get_x value)
  let y.chk = Apps.Fib.Pos.Coord.IsValid (Apps.Fib.Pos.Value.get_y value)
  Pair x.chk y.chk

// Gets the x component of a U120 position value.
Apps.Fib.Pos.Value.get_x (val: U120) : U120 {
  U120.bitwise_and val (U120.new 0 511)
}

// Gets the y component of a U120 position value.
Apps.Fib.Pos.Value.get_y (val: U120) : U120 {
  U120.bitwise_and (U120.shift_right val (U120.new 0 9)) (U120.new 0 511)
}

// Creates a U120 value from a x and a y.
Apps.Fib.Pos.Value.new (x: U120) (y: U120) {
  U120.bitwise_or (U120.shift_left y (U120.new 0 9)) x
}

// Creates a position from a x and a y.
Apps.Fib.Pos.new (x: U120) (y: U120) : Apps.Fib.Pos {
  let x.val = U120.mod x (U120.new 0 320)
  let y.val = U120.mod y (U120.new 0 320)
  $ (Apps.Fib.Pos.Value.new x.val y.val)
    ?
}

// [U120.and.pass_or]          For every a b c: (& (| a b) c) == (| (& a b) (& b c))
// [U120.shift_left.mask_zero] For every a s: (<< a s) & (- (1 << s) 1) == 0
// [U120.or.zero_right]        For every a: (| a 0) == a
// [U120.and.less_than_a]      For every a b: (& a b) <= a
// [U120.and.less_than_b]      For every a b: (& a b) <= b
// [U120.mod.is_less_than]     For every a b: (% a b) < b
// [U120.IsGreaterThan.chain]  For every a b c, if a <= b and b < c: a < c

// O objetivo #1:
// - (< (& (| (<< (% y 320) 9) (% x 320)) 511) 320)
// O plano:
// - e0: (& (% x 320) 511) <= (% x 320)                       // usando U120.and.less_than_a
// - e1: (% x 320) < 320                                      // usando U120.mod.is_less_than
// - e2: (& (% x 320) 511) < 320                              // usando U120.IsGreaterThan.chain em e0 e e1
// - e3: (| 0 (& (% x 320) 511)) < 320                        // usando U120.or.zero_left
// - e4: (| (& (<< (% y 320) 9) 511) (& (% x 320) 511)) < 320 // usando U120.shift_left.mask_zero
// - e5: (& (| (<< (% y 320) 9) (% x 320)) 511) < 320         // usando U120.and.pass_or
// - qed
Apps.Fib.Pos.new.aux0 (x: U120) (y: U120)
: (Equal Bool
    (U120.less_than
      (U120.bitwise_and (U120.bitwise_or (U120.shift_left (U120.mod y (U120.new 0 320)) (U120.new 0 9)) (U120.mod x (U120.new 0 320))) (U120.new 0 511))
      (U120.new 0 320))
    Bool.true)
Apps.Fib.Pos.new.aux0 x y = ?

// O objetivo #2:
// - ?
// O plano:
// - descubra
Apps.Fib.Pos.new.aux1 (x: U120) (y: U120)
: (Equal Bool
    (U120.less_than
      (U120.bitwise_and (U120.shift_right (U120.bitwise_or (U120.shift_left (U120.mod y (U120.new 0 320)) (U120.new 0 9)) (U120.mod x (U120.new 0 320))) (U120.new 0 9)) (U120.new 0 511))
      (U120.new 0 320))
    Bool.true)
Apps.Fib.Pos.new.aux1 x y = ?

// Gets the x component of a U120 position.
Apps.Fib.Pos.get_x (pos: Apps.Fib.Pos) : U120 
Apps.Fib.Pos.get_x (Sigma.new p.a p.b value valid) = Apps.Fib.Pos.Value.get_x value

// Gets the x component of a U120 position.
Apps.Fib.Pos.get_y (pos: Apps.Fib.Pos) : U120 
Apps.Fib.Pos.get_y (Sigma.new p.a p.b value valid) = Apps.Fib.Pos.Value.get_y value

// Adds two positions
// a.x + b.x tem que ser menor que 320
// comportamento = wrap around
//Apps.Fib.Pos.add (a: Apps.Fib.Pos) (b: Apps.Fib.Pos) : Apps.Fib.Pos
//Apps.Fib.Pos.add (Sigma.new a.a a.b a.value a.valid) (Sigma.new b.a b.b b.value b.valid) =
  //let a.x = Apps.Fib.Pos.Value.get_x a.value
  //let a.y = Apps.Fib.Pos.Value.get_y a.value
  //let b.x = Apps.Fib.Pos.Value.get_x b.value
  //let b.y = Apps.Fib.Pos.Value.get_y b.value
  //let c.x = U120.mod (U120.add a.x b.x) (U120.new 0 320)
  //let c.y = U120.mod (U120.add a.y b.y) (U120.new 0 320)
  //Apps.Fib.Pos.new c.x c.y

//Apps.Fib.Pos.add.safe (a: Apps.Fib.Pos) (b: Apps.Fib.Pos) (e: ..............)
  //let a.x = Apps.Fib.Pos.Value.get_x a.value
  //let a.y = Apps.Fib.Pos.Value.get_y a.value
  //let b.x = Apps.Fib.Pos.Value.get_x b.value
  //let b.y = Apps.Fib.Pos.Value.get_y b.value
  //let c.x = U120.mod (U120.add a.x b.x) (U120.new 0 320)
  //let c.y = U120.mod (U120.add a.y b.y) (U120.new 0 320)
  //let val = .................
  //$ .........
  //  .........
